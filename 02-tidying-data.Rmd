# O pacote tidyr {#tidyr}

Dentro do `tidyverse`, um dataset *tidy* é uma base fácil de se trabalhar, isto é, fácil de se fazer manipulação de dados, criar visualizações e de se ajustar modelos. 

Na prática, uma base *tidy* é aquela que se encaixa bem no *framework* do `tidyverse`, pois os pacotes como o `dplyr` e o `ggplot2` foram desenvolvidos para funcionar bem com bases *tidy*. O conceito *tidy* pode ser simplificado e definido utilizando-se de duas propriedades, as mais importantes, de uma base *tidy* que são:

- cada coluna é uma variável;

- cada linha é uma observação.

Isto nos proporciona uma maneira consistente de se referir às variáveis e observações.

O pacote `{tidyr}` possui funções que nos ajudam a transformar uma base **não bem formatada** em uma base *tidy* (bem formatada). Ou então, nos ajudam a retirar do formato *tidy* quando isso nos convém.

Vamos ver aqui algumas de suas principais funções:

- `separate()` e `unite()`: para separar variáveis concatenadas em uma única coluna ou uni-las.

- `pivot_wider()` e `pivot_longer()`: para pivotar a base.

- `nest()` e `unnest()`: para criar *list columns*.

Como motivação para utilizar esssas funções.

```{r, include = FALSE}
library(tidyverse)

customers <- read_csv("https://raw.githubusercontent.com/brunolucian/CursoIntermediarioR/main/Dados/olist_customers_dataset.csv")

```



### `separate()` e `unite()`

A função `separate()` separa duas ou mais variáveis que estão concatenadas em 
uma mesma coluna. A sintaxe da função está apresentada abaixo.

```{r eval=FALSE}
dados %>% 
  separate( 
    col = coluna_antiga, 
    into = c("Part_1", "Part_2"),
    sep = "separador"
  )
```

Para ilustrar o uso das funções supracitadas vamos manipular o *dataset* 
que já trabalhamos no módulo anterior e se encontra num formato *tidy*. Por
isso iremos retirar a formatação já criada anteriormente, criando assim uma situação
mais real do dia a dia do analista de dados. E para isso usaremos a função 
*unite()*, que pertence ao pacote *tidyr*, dentro da nossa cadeia de código.

```{r}

df_messy <- customers %>% 
  mutate(customer_state = str_to_lower(customer_state)) %>% 
  unite(customer_state, customer_city, col = "state_city") %>% 
  select(-customer_unique_id)

df_messy

```

Agora com nosso *dataset* não bem estruturado vamos tentar elucidar o uso da 
função *separate()* fazendo com que o *dataframe* utilizado retorne ao formato 
original.

```{r}

df_clean <- df_messy %>% 
  separate(state_city, sep = "_", into = c("customer_state", "customer_city")) 
  
df_clean

```


### Pivotagem

O conceito de pivotagem no *tidyverse* se refere a mudança da estrutura da base, 
normalmente para alcançar o formato *tidy*. 

Geralmente realizamos pivotagem quando nossas linhas não são unidades observacionais
ou nossas colunas não são variáveis. Ela é similiar à pivotagem do Excel, mas um pouco mais complexa.

O ato de pivotar resulta em transformar uma base de dados *long* em *wide* e vice-versa. 

Uma base no formato *long* possui mais linhas e pode ter menos colunas, 
enquanto no formato *wide* possui menos linhas e pode ter mais colunas.

Esses formatos são sempre relativos às colunas que estão sendo pivotadas, 
sendo que uma base *tidy* pode estar tanto no formato *long* quanto *wide*.

Antigamente, utilizávamos as funções `gather()` e `spread()` para fazer as 
operações de pivotagem. 

Agora, no lugar de `gather()`, utilizamos a função `pivot_longer()`. 
Abaixo, transformamos as colunas `ator1`, `ator2` e `ator3` em duas colunas: 
`ator_atriz` e `protagonismo`.

```{r}

n_state_city <- customers %>% 
  count(customer_state, customer_city)

n_state_city
```

```{r}
n_state_city_wider <- n_state_city %>% pivot_wider(names_from = customer_state, values_from = n)
n_state_city_wider

```


A função `pivot_wider()` faz a operação inversa da `pivot_longer()`. Sem aplicarmos as duas funções em sequência, voltamos para a base original.

```{r}
n_state_city_wider %>% 
  pivot_longer(2:28, names_to = "customer_state", values_to = "n", values_drop_na = T)
```


### *List columns*

Um terceiro conceito de dados *tidy* é que cada célula da tabela possui um valor. No entanto, quando estamos programando, muitas vezes vale apena abandonar essa definição e guardarmos objetos mais complexos nas células de uma tabela.

Utilizando as chamadas *list columns* podemos guardar virtualmente qualquer objeto em nossas *tibbles*, como gráficos, resultados de modelos ou até mesmo outras tabelas.

Uma forma de trabalhar com *list columns* consiste em utilizarmos as funções

- `nest()`: para criar uma *list column*;

- `unnest()`: para desfazer uma *list column*.

A forma mais simples de utilizarmos uma *list column* é *aninhar* a nossa base com relação a uma variável.

```
